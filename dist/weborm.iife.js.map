{"version":3,"file":"weborm.iife.js","sources":["../src/storable/entity.ts","../src/queryResult.ts","../src/repository/index.ts","../src/drivers/index.ts","../src/drivers/fallback.ts","../src/debug.ts","../src/orm/constructor.ts","../src/orm/index.ts"],"sourcesContent":["import { IStorable } from './istorable';\r\n\r\nexport class Entity implements IStorable {\r\n  constructor(options) {\r\n    \r\n  }\r\n\r\n  public repository;\r\n\r\n  public $save() {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  public $delete() {\r\n    return Promise.resolve();\r\n  }\r\n}","/**\r\n * Incapsulates the query result data for further manipulation\r\n *\r\n * @template T the type of data encapsulated\r\n */\r\nexport class QueryResult<T> {\r\n  private _ok: boolean;\r\n  private _result: Promise<T>;\r\n  private handlers: Function[] = [];\r\n\r\n  constructor(ok: boolean, result: Promise<T>, public readonly error?: Error) {\r\n    this._ok = ok;\r\n    this._result = result;\r\n  }\r\n\r\n  /**\r\n   * Determines whether the incapsulated data is OK and contains no errors\r\n   */\r\n  public get ok() { return this._ok; }\r\n\r\n  /**\r\n   * The resulting data of the query request\r\n   */\r\n  public get result() { return this._result; }\r\n  public set result(value: Promise<T>) {\r\n    this._result = value;\r\n    this.handlers.forEach(async h => h());\r\n  }\r\n\r\n  \r\n  /**\r\n   * Fires a handler whenever the data in the result has been changed\r\n   *\r\n   * @param callback the callback to fire\r\n   */\r\n  public onChange(callback: Function) {\r\n    this.handlers.push(callback);\r\n  }\r\n  \r\n  /**\r\n   * Unsubscribe the callback from the result data changes\r\n   */\r\n  public offChange(callback: Function) {\r\n    const idx = this.handlers.indexOf(callback);\r\n\r\n    if (idx > -1) {\r\n      this.handlers.splice(idx, 1);\r\n    }\r\n  }\r\n}","import { QueryResult } from '../queryResult';\r\nimport { Connection } from '../orm';\r\nimport { IStorable, IStorableConstructor } from '../storable';\r\n\r\n/**\r\n * @TODO:\r\n * - Async API MAP crap for handling QueryResults\r\n */\r\n\r\nexport interface IRepository {\r\n  name: string;\r\n\r\n  readonly connection: Connection;\r\n  readonly columns: Array<string>;\r\n  readonly primaryKey: string | number | symbol;\r\n}\r\n\r\nexport class Repository<\r\n  C extends IStorableConstructor<E>,\r\n  E extends IStorable = InstanceType<C>,\r\n  A extends ConstructorParameters<C>[0] = ConstructorParameters<C>[0]\r\n> implements IRepository {\r\n  public readonly columns: Array<string>;\r\n  public readonly primaryKey: string | number | symbol;\r\n  \r\n  constructor(\r\n    public name: string,\r\n    public readonly connection: Connection,\r\n    protected entity: C\r\n  ) {\r\n    this.primaryKey = entity.prototype.__id__;\r\n    this.columns = Object.keys(entity.prototype.__col__);\r\n    delete entity.prototype.__col__;\r\n  }\r\n\r\n  public add(options: A): QueryResult<E> {\r\n    return new QueryResult(\r\n      true,\r\n      Promise.resolve(new this.entity(options))\r\n    );\r\n  }\r\n  \r\n  public get(id: any): QueryResult<E> {\r\n    return new QueryResult(\r\n      true,\r\n      Promise.resolve(new this.entity({}))\r\n    );\r\n  }\r\n  \r\n  public update(id: any, options: Partial<A>): QueryResult<E> {\r\n    return new QueryResult(true, Promise.resolve(new this.entity(options)));\r\n  }\r\n  \r\n  public delete(id: any): QueryResult<E> {\r\n    return new QueryResult(true, Promise.resolve(new this.entity({})));\r\n  }\r\n\r\n  // TODO: Find, find by, etc...\r\n}\r\n\r\n","import { Connection } from '../orm';\r\n\r\nexport interface IDriverConstructor extends Function {\r\n  new (connection: Connection): Driver;\r\n\r\n  readonly isSupported: boolean;\r\n}\r\n\r\nexport abstract class Driver {\r\n  constructor(\r\n    protected connection: Connection\r\n  ) {}\r\n\r\n  public abstract create<T extends object>(repositoryName: string, entity: T): Promise<T>;\r\n  public abstract read<T extends object>(repositoryName: string, id: any): Promise<T>;\r\n  public abstract update<T extends object>(repositoryName: string, id: any, data: Partial<T>): Promise<T>;\r\n  public abstract update<T extends object>(repositoryName: string, entity: Partial<T>): Promise<T>;\r\n  public abstract delete<T extends object>(repositoryName: string, id: any): Promise<T>;\r\n  public abstract delete<T extends object>(repositoryName: string, entity: Partial<T>): Promise<T>;\r\n\r\n  /**\r\n   * Determines if the driver is supported in current environment\r\n   */\r\n  static get isSupported(): boolean {\r\n    throw new Error('Not implemented.');\r\n  }\r\n}\r\n","import { Driver } from '.';\r\nimport { Repository } from '../repository';\r\nimport { QueryResult } from '../queryResult';\r\n\r\nexport class FallbackDriver extends Driver {\r\n  public create<T extends object>(repositoryName: string, entity: T): Promise<T> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  public read<T extends object>(repositoryName: string, id: any): Promise<T> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  public update<T extends object>(repositoryName: string, id: any, data: Partial<T>): Promise<T>;\r\n  public update<T extends object>(repositoryName: string, entity: Partial<T>): Promise<T>;\r\n  public async update(repositoryName: any, id: any, data?: any) {\r\n    throw new Error('Method not implemented.');\r\n\r\n    return {};\r\n  }\r\n  public delete<T extends object>(repositoryName: string, id: any): Promise<T>;\r\n  public delete<T extends object>(repositoryName: string, entity: Partial<T>): Promise<T>;\r\n  public async delete(repositoryName: any, entity: any) {\r\n    throw new Error('Method not implemented.');\r\n    \r\n    return {};\r\n  }\r\n\r\n  \r\n}","const LOG_PREFIX = (name: string) => name ? `[WebORM:${name}]` : `[WebORM]`;\r\n\r\nexport type ExceptionType = 'soft' | 'hard';\r\nexport type DebugType = '*'\r\n  | 'connection'\r\n  | 'driver'\r\n  | 'driver:[name]'\r\n  | 'db'\r\n  | 'db:[name]'\r\n  | 'db:[name]:entity'\r\n  | 'db:[name]:entity:[name]';\r\n\r\nexport type IDebugMap = Partial<{\r\n  [key: string]: boolean | ExceptionType;\r\n}>;\r\n\r\nexport type LogLevel = 'log' | 'debug' | 'warn' | 'error';\r\n\r\n\r\nexport abstract class Debug {\r\n  protected static debugState: 'enabled' | 'disabled' | 'custom' = 'disabled';\r\n\r\n  /**\r\n   * Contains the map for all debug types and their respective error types for the ORM.\r\n   */\r\n  public static readonly map: IDebugMap = {};\r\n\r\n  \r\n  /**\r\n   * `true` if any debug is enabled\r\n   */\r\n  public static get isEnabled() { return this.debugState !== 'disabled'; }\r\n\r\n  /**\r\n   * Shows the current debug state of WebORM\r\n   * \r\n   * - `enabled` - all the logs and exceptions are enabled\r\n   * - `custom` - custom rules are set via a `debug()` function\r\n   * - `disabled` - all the logs and most exceptions are suppressed\r\n   */\r\n  public static get state() { return this.debugState; }\r\n  public static set state(v) { this.debugState = v; }\r\n\r\n  \r\n  public static error(instanceName: string, type: string, message: string);\r\n  public static error(instanceName: string, type: RegExp, message: string);\r\n  public static error(instanceName: string, type: DebugType, message: string);\r\n  public static error(instanceName: string, type: any, message: string) {\r\n    return this.print(instanceName, type, message, 'error');\r\n  }\r\n\r\n  public static log(instanceName: string, type: string, message: string);\r\n  public static log(instanceName: string, type: RegExp, message: string);\r\n  public static log(instanceName: string, type: DebugType, message: string);\r\n  public static log(instanceName: string, type: any, message: string) {\r\n    return this.print(instanceName, type, message, 'log');\r\n  }\r\n  \r\n  public static warn(instanceName: string, type: string, message: string);\r\n  public static warn(instanceName: string, type: RegExp, message: string);\r\n  public static warn(instanceName: string, type: DebugType, message: string);\r\n  public static warn(instanceName: string, type: any, message: string) {\r\n    return this.print(instanceName, type, message, 'warn');\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the current error type for a specific type of debugging\r\n   */\r\n  public static errorType(type: string): boolean | ExceptionType;\r\n  public static errorType(type: RegExp): boolean | ExceptionType;\r\n  public static errorType(type: DebugType): boolean | ExceptionType;\r\n  public static errorType(type: string | RegExp | DebugType): boolean | ExceptionType {\r\n    if (this.map['*']) { return true; }\r\n\r\n    const isString = (t): t is string => typeof t === 'string';\r\n\r\n    if (isString(type) && this.map[type]) {\r\n      return this.map[type]!;\r\n    }\r\n\r\n    if (isString(type)) {\r\n      const matchingType = Object.keys(this.map)\r\n        .find(t => !!t && t.includes(type) && !!this.map[t]) as ExceptionType | undefined;\r\n\r\n      return matchingType || false;\r\n    }\r\n\r\n    return (Object.keys(this.map).find(t => type.test(t)) as ExceptionType | undefined) || false;\r\n  }\r\n\r\n  \r\n  public static print(instanceName: string, type: any, message: string, level: LogLevel) {\r\n    if (this.debugState !== 'disabled') {\r\n      const typeOfError = this.errorType(type);\r\n      if (typeOfError) {\r\n        if (typeOfError === 'hard' && level === 'error') {\r\n          throw new Error(`${LOG_PREFIX(instanceName)}:${type} - ${message}`);\r\n        } else {\r\n          console[level](`%c${LOG_PREFIX(instanceName)}%c:%c${type}%c - ${message}`,\r\n            'color: purple',\r\n            'color: initial',\r\n            'color: blue',\r\n            'color: initial'\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static decoratedLogs: any = {};\r\n\r\n  public static prints(message: string, level: LogLevel = 'log', type: DebugType = '*') {\r\n    return (target, key: string, desc: PropertyDescriptor) => {\r\n      Object.defineProperty(this.decoratedLogs, key, desc || {\r\n        value: undefined,\r\n        writable: true,\r\n        enumerable: true\r\n      });\r\n      Object.defineProperty(target, key, {\r\n        get: () => {\r\n          this.print('', type, message, level);\r\n  \r\n          return this.decoratedLogs[key];\r\n        },\r\n        set: v => {\r\n          this.decoratedLogs[key] = v;\r\n        }\r\n      });\r\n    };\r\n  }\r\n  \r\n}\r\n","import { Repository } from '../repository';\r\nimport { Driver, IDriverConstructor } from '../drivers';\r\nimport { FallbackDriver } from '../drivers/fallback';\r\nimport { IStorableConstructor } from '../storable';\r\nimport { Debug } from '../debug';\r\nimport { DebugType, ExceptionType } from '../debug';\r\n\r\nexport interface IRepositoryMap {\r\n  [name: string]: IStorableConstructor<any>;\r\n}\r\n\r\nexport type RepoStore<M extends IRepositoryMap> = {\r\n  [name in keyof M]: Repository<\r\n  M[name]\r\n  >;\r\n};\r\n\r\nexport class Connection<T extends IRepositoryMap> {\r\n  // TODO\r\n  // public static readonly plugins: WebORM.IPlugin[] = [];\r\n\r\n  /**\r\n   * The driver currently used for operations with entities\r\n   */\r\n  public currentDriver: Driver;\r\n\r\n  /**\r\n   * A current map of bound repositories\r\n   */\r\n  public repositories: RepoStore<T> = {} as any;\r\n\r\n  /**\r\n   * Creates an instance of WebOrm.\r\n   * @param connectionName the name of the connection to the storage. Namespaces all respositories invoked from the instance.\r\n   * @param drivers determine a variety of drivers the orm can select from. The first one that fits for the environment is selected.\r\n   * @param repositories sets the relation of a repository name to its contents' prototype.\r\n   * @param apiMap maps the API calls onto the current entity structure\r\n   */\r\n  constructor(\r\n    public connectionName: string,\r\n    public drivers: IDriverConstructor[],\r\n    repositories: T,\r\n    private apiMap?: any // TODO\r\n  ) {\r\n    // Select the first supported driver from the bunch\r\n    const SupportedDriver = drivers.find(d => d.isSupported);\r\n\r\n    if (SupportedDriver) {\r\n      // TODO: multi-driver mode\r\n      Debug.log(\r\n        this.connectionName,\r\n        'orm',\r\n        `Using driver \"${SupportedDriver.name}\" as the first supported driver`\r\n      );\r\n\r\n      this.currentDriver = new SupportedDriver(this);\r\n    } else {\r\n      Debug.warn(\r\n        this.connectionName,\r\n        'orm',\r\n        'No supported driver provided. Using fallback.'\r\n      );\r\n\r\n      this.currentDriver = new FallbackDriver(this);\r\n    }\r\n\r\n    let reProxy;\r\n\r\n    if (!Proxy) {\r\n      Debug.warn(\r\n        this.connectionName,\r\n        'orm',\r\n        `window.Proxy is unavailable. Using insufficient property forwarding.`\r\n      );\r\n\r\n      reProxy = (repoName: string) => Object.defineProperty(this, repoName, {\r\n        get: () => this.repositories[repoName],\r\n      });\r\n    }\r\n\r\n    for (const repoName in repositories) {\r\n      const entityConstructor = repositories[repoName];\r\n\r\n      this.repositories[repoName] = new Repository(repoName, this, entityConstructor);\r\n\r\n      reProxy && reProxy(repoName);\r\n    }\r\n\r\n    if (Proxy) {\r\n      Debug.log(\r\n        this.connectionName,\r\n        'orm',\r\n        `window.Proxy is available. Using modern property forwarding.`\r\n      );\r\n\r\n      return new Proxy(this, {\r\n        get(target, key: string) {\r\n          if (!target.repositories[key]) {\r\n            if (!target[key]) {\r\n              Debug.log(\r\n                target.connectionName,\r\n                'orm',\r\n                `Repository \"${key}\" is not registered upon initialization. No other property with the same name was found.`\r\n              );\r\n            }\r\n\r\n            return target[key];\r\n          }\r\n\r\n          return target.repositories[key];\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  //#region Debug\r\n\r\n  /**\r\n   * Enable a certain debug option for WebORM\r\n   *\r\n   * Allows for detailed debug type - exception type mapping.\r\n   */\r\n  public static debug(enabled: boolean): void;\r\n  public static debug(type: DebugType): void;\r\n  public static debug(type: DebugType, exceptions: ExceptionType): void;\r\n  public static debug(type: string): void;\r\n  public static debug(type: string, exceptions: ExceptionType): void;\r\n  public static debug(type: boolean | string, exceptions?: ExceptionType) {\r\n    if (typeof type === 'boolean') {\r\n      Debug.state = (type ? 'enabled' : 'disabled');\r\n    } else {\r\n      Debug.state = ('custom');\r\n\r\n      Debug.map[type] = exceptions || !Debug.map[type];\r\n    }\r\n  }\r\n\r\n  //#endregion\r\n}\r\n","import { IDriverConstructor } from '../drivers';\r\nimport { Entity } from '../storable/entity';\r\nimport { Connection as connection, IRepositoryMap, RepoStore } from './constructor';\r\n\r\nexport const Connection = connection as {\r\n  /**\r\n   * Creates an instance of WebOrm.\r\n   * @param name the name of the connection to the storage. Namespaces all respositories invoked from the instance.\r\n   * @param drivers determine a variety of drivers the orm can select from. The first one that fits for the environment is selected.\r\n   * @param repositories sets the relation of a repository name to its contents' prototype.\r\n   * @param apiMap maps the API calls onto the current entity structure\r\n   */\r\n  new <T extends IRepositoryMap>(\r\n      name: string,\r\n      drivers: IDriverConstructor[],\r\n      repositories: T,\r\n      apiMap?: any // TODO\r\n  ): connection<T> & RepoStore<T>;\r\n} & typeof connection;\r\n\r\nexport type Connection<T extends IRepositoryMap = any> = connection<T>;\r\n\r\nexport * from './namespace';\r\n\r\nclass Product extends Entity {\r\n  constructor(options: {\r\n      title: string;\r\n      url: string;\r\n  }) {\r\n    super(options);\r\n  }\r\n}\r\n\r\nclass User extends Entity {\r\n  constructor(options: {\r\n    name: string;\r\n    birthDate: Date;\r\n    cart: Product[];\r\n  }) {\r\n    super(options);\r\n  }\r\n}\r\n\r\nconst orm = new Connection('asd', [], {\r\n  Products: Product,\r\n  User\r\n});\r\n\r\norm.User.add({\r\n  name: 'max',\r\n  birthDate: new Date(),\r\n  cart: [\r\n    new Product({\r\n      title: 'podguzniki',\r\n      url: '/package.json'\r\n    })\r\n  ]\r\n});\r\n\r\n\r\norm.User.update(0, {\r\n  \r\n});\r\n\r\norm.Products.delete(1);"],"names":["tslib_1.__extends","Connection","connection"],"mappings":"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"}